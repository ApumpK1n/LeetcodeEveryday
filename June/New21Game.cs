// 837. 新21点
public class Solution {
    //核心思路：本次抽牌后，能否获胜，由当前结果，和下一次抽牌概率决定
    //由最后一张牌反推到第一张牌：
    //用x表示当前分数，dp[x]表示能获胜的概率，x 的取值区间[0, k+w-1] （倒数第2次最大是k-1，再加上最后一次最大值w）
    //
    //则当分数x在区间[k, min(n, k+w-1)] 时，抽牌停止，胜利，此时dp[x] = 1 
    //当分数x在大于n时，抽牌停止，失败，此时dp[x] = 0
    //   当 0 < x < k 时，获胜的概率，就是下一张牌的各种牌面概率获胜之和
    //   即：dp[x] = (dp[x+1] + dp[x+2] + ... + dp[x+w])/ w
    //   优化，当 0 <= x < k - 1时，（注意：当 x == k-1时，dp[x+1] = dp[k]，最后一项为dp[k+w]已经超出取值范围[0, k+w-1],所以不适用）
    //   因为 dp[x+1] = (dp[x+2] + dp[x+3] + ... + dp[x+1+w])/ w
    //   上面两式相减得 dp[x] - dp[x+1] = (dp[x+1] - dp[x+1+w])/ w
    //   所以：dp[x] = (dp[x+1] - dp[x+1+w])/ w + dp[x+1]
    public double New21Game(int N, int K, int W) {
        //当k为0时，不需要抽牌，且 0<= n 所以概率是1
        if (K == 0)
        {
            return 1.0;
        }
        double[] dp = new double[K + W];
        //获胜的分数区间[k, min(n, k+w-1)],当分数落到这个区间，胜率为1
        //分数不少于k时，抽牌就停止
        //所以，还需要抽牌的最大分数是就是k-1 (换言之，分数大于k-1就不再抽卡了)
        //当分数是k - 1时，再从[1, w]中抽一张卡，可得到的分数是[k, k + w]
        //又因为分数不超过n才胜利，所以：胜利区间是：[k, min(n, k+w-1)]
        for (int i = K; i <= N && i < K + W; i++)
        {
            dp[i] = 1.0;
        }
        //当目前分数x=k-1时，再抽一张牌结束。如果再抽的牌在区间[1, n - (k-1)], 则胜利
        dp[K - 1] = 1.0 * Math.Min(N - K + 1, W) / W;
            
        for (int i = K - 2; i >= 0; i--)
        {
            //状态转移方程
            dp[i] = (dp[i + 1] - dp[i + W + 1])/W + dp[i + 1];
        }

        return dp[0];
    }
}
